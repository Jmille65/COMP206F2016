def multByTwo(x):
    return x*2

def multByThree(x):
    return x*3

# old-school:
# def applyToList(x,f):
#     if not x:
#         return []
#     else:
#         return [f(x[0])] + applyToList(x[1:],f)

def applyToList(x, f):
    return map((lambda y: f(y)), x)

# one-line magic:
from functools import reduce
def buildFuncFromList(lf):
    return reduce((lambda f, acc: (lambda x: f(acc(x)))), lf)

print applyToList([1,2,3], buildFuncFromList([(lambda x: x*2),(lambda x: x*3)]))

# have I gone too far?
print (lambda x, f: map((lambda y: f(y)), x))([1,2,3], (lambda lf: reduce((lambda f, acc: (lambda x: f(acc(x)))), lf))([(lambda x: x*2),(lambda x: x*3)]))

import math
print math.log(38551198780776703514355955497864152183598006125462813941048147830661410124871689249458172947338248134685368078604994824008462930800048695654547380219934646059963343556836619886147206040157138938291186270481785513522834718953467680465801070793435469571413363977980169492638019789571739289248778281273817755350571672131432604180208209650249952275587237642764122659427364980856405106475624194319026520722989631118206494985135983970546134618152777599185098962898690031134771071360860966758519962712225627768799968341130430478888025980928000000000000000000000000000000000000000000000000000000000000000000000000)
